if not fs.exists(shell.resolve("aes")) then
  local httpfile = http.get("https://git.io/aeslua")
  if not httpfile then
    printError("Failed to download AES.")
    return
  end
  local file = fs.open(shell.resolve("aes"),"w")
  if not file then
    printError("Failed to download AES.")
    httpfile.close()
    return
  end
  file.write(httpfile.readAll())
  httpfile.close()
  file.close()
end
if not aes then
  if not os.loadAPI(shell.resolve("aes")) then
    printError("Failed to load AES.")
    return
  end
end

local tArgs = {...}

if #tArgs < 4 or (tArgs[1] ~= "encrypt" and tArgs[1] ~= "decrypt") then
  printError("Usage: "..shell.getRunningProgram().." encrypt <from> <to> <password>")
  printError("       "..shell.getRunningProgram().." decrypt <from> <to> <password>")
  return
end

if not fs.exists(shell.resolve(tArgs[2])) then
  printError("File doesn't exist.")
  return
end

local function getTruePath(path)
  path = "/"..path.."/"
  repeat
    path = path:gsub("//","/")
  until not path:find("//")
  return path
end

local function yield()
  os.queueEvent("yield")
  os.pullEventRaw("yield")
end

local function recursiveLookup(path)
  yield()
  local c
  if fs.isReadOnly(path) then
    return
  end
  if fs.isDir(path) then
    c = {
      d = true,
      c = {},
    }
    for i,name in pairs(fs.list(path)) do
      c.c[name] = recursiveLookup(path..name.."/")
    end
  else
    print("Encrypting \""..path:sub(1,#path-1).."\"...")
    c = {
      d = false,
      c = ""
    }
    local file = fs.open(path,"r")
    if file then
      c.c = file.readAll()
      file.close()
    end
  end
  return c
end

local function recursiveDownload(path,files)
  yield()
  if files.d then
    for name,content in pairs(files.c) do
      recursiveDownload(path..name.."/",content)
    end
  else
    print("Decrypting \""..path:sub(1,#path-1).."\"...")
    local file = fs.open(path,"w")
    if file then
      file.write(files.c)
      file.close()
    end
  end
  return
end

local function lpad(str,pad,len)
  if #str < len then
    repeat
      str = pad..str
    until #str >= len
  end
  return str
end

local function toHex(str)
  local hex = ""
  for i=1,#str,1 do
    hex = hex..lpad(string.format("%x",string.byte(str:sub(i,i))),"0",2)
    yield()
  end
  return hex
end

local function fromHex(hex)
  local str = ""
  for i=1,#hex,2 do
    str = str..string.char(tonumber(hex:sub(i,i+1),16))
    yield()
  end
  return str
end

if tArgs[1] == "encrypt" then
  local to = fs.open(getTruePath(shell.resolve(tArgs[3])),"w")
  if not to then
    printError("Failed to open destination file.")
    return
  end
  to.write(toHex(aes.encrypt(tArgs[4],data.deflate(textutils.serialize(recursiveLookup(getTruePath(shell.resolve(tArgs[2]))))))))
  to.close()
  printError("Encryption complete!")
else
  local from = fs.open(getTruePath(shell.resolve(tArgs[2])),"r")
  if not from then
    printError("Failed to open source file.")
    from.close()
    return
  end
  local files
  local ok, err = pcall(function()
    files = textutils.unserialize(data.inflate(aes.decrypt(tArgs[4],fromHex(from.readAll()))))
  end)
  from.close()
  if not (ok and files) then
    if err then
      printError("Failed to read source file: "..err)
    else
      printError("Failed to read source file.")
    end
    return
  end
  if files.d and not fs.exists(shell.resolve(tArgs[3])) then
    fs.makeDir(shell.resolve(tArgs[3]))
  end
  recursiveDownload(getTruePath(shell.resolve(tArgs[3])),files)
  printError("Decryption complete!")
end
