if not fs.exists(shell.resolve("aes")) then
  local httpfile = http.get("https://git.io/aeslua")
  if not httpfile then
    printError("Failed to download AES.")
    return
  end
  local file = fs.open(shell.resolve("aes"),"w")
  if not file then
    printError("Failed to download AES.")
    httpfile.close()
    return
  end
  file.write(httpfile.readAll())
  httpfile.close()
  file.close()
end
if not aes then
  if not os.loadAPI(shell.resolve("aes")) then
    printError("Failed to load AES.")
    return
  end
end

local tArgs = {...}

if #tArgs < 4 or (tArgs[1] ~= "encrypt" and tArgs[1] ~= "decrypt") then
  printError("Usage: "..shell.getRunningProgram().." <encrypt/decrypt> <from file/dir> <to> <password>")
  return
end

if not fs.exists(shell.resolve(tArgs[2])) then
  printError("File doesn't exist.")
  return
end

local function getTruePath(path)
  path = "/"..path.."/"
  repeat
    path = path:gsub("//","/")
  until not path:find("//")
  return path
end

local function recursiveLookup(path)
  os.queueEvent("yield")
  os.pullEventRaw("yield")
  local content
  if fs.isReadOnly(path) then
    return
  end
  if fs.isDir(path) then
    content = {
      isDir = true,
      content = {},
    }
    for i,name in pairs(fs.list(path)) do
      content.content[name] = recursiveLookup(path..name.."/")
    end
  else
    print("Uploading \""..path:sub(1,#path-1).."\"...")
    content = {
      isDir = false,
      content = ""
    }
    local file = fs.open(path,"r")
    if file then
      content.content = file.readAll()
      file.close()
    end
  end
  return content
end

local function recursiveDownload(path,files)
  os.queueEvent("yield")
  os.pullEventRaw("yield")
  if files.isDir then
    for name,content in pairs(files.content) do
      recursiveDownload(path..name.."/",content)
    end
  else
    print("Downloading \""..path:sub(1,#path-1).."\"...")
    local file = fs.open(path,"w")
    if file then
      file.write(files.content)
      file.close()
    end
  end
  return
end

local function lpad(str,pad,len)
  if #str < len then
    repeat
      str = pad..str
    until #str >= len
  end
  return str
end

local function toHex(str)
  local hex = ""
  for i=1,#str,1 do
    hex = hex..lpad(string.format("%x",string.byte(str:sub(i,i))),"0",2)
  end
  return hex
end

local function fromHex(hex)
  local str = ""
  for i=1,#hex,2 do
    str = str..string.char(tonumber(hex:sub(i,i+1),16))
  end
  return str
end

if tArgs[1] == "encrypt" then
  local to = fs.open(getTruePath(shell.resolve(tArgs[3])),"w")
  if not to then
    printError("Failed to open destination file.")
    return
  end
  to.write(toHex(aes.encrypt(tArgs[4],textutils.serialize(recursiveLookup(getTruePath(shell.resolve(tArgs[2])))))))
  to.close()
  printError("Encryption complete!")
else
  local from = fs.open(getTruePath(shell.resolve(tArgs[2])),"r")
  if not from then
    printError("Failed to open source file.")
    from.close()
    return
  end
  local files
  local ok, err = pcall(function()
    files = textutils.unserialize(aes.decrypt(tArgs[4],fromHex(from.readAll())))
  end)
  from.close()
  if not (ok or files) then
    printError("File is corrupt!")
    return
  end
  if files.isDir then
    fs.makeDir(shell.resolve(tArgs[3]))
  end
  recursiveDownload(getTruePath(shell.resolve(tArgs[3])),files)
  printError("Decryption complete!")
end
